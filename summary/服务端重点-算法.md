# 服务端重点-算法

## 端到端

#### 算法与数据结构

[leetcode刷题指南](https://leetcode-cn.com/circle/article/wGp7Y9/)

##### 算法分析

###### 算法复杂度

省略常数时：
O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)

平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？

其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，「但我们统一说 logn，也就是忽略底数的描述」。

###### 二分法 [link](https://mp.weixin.qq.com/s/fCf5QbPDtE6SSlZ1yh_q8Q)

问题：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

分析：插入目标值，无非四种情况
![image](https://mmbiz.qpic.cn/mmbiz_png/F1VzfUpxxe7XJru4qDFXKM7asqfwvgEGFqBfLgibiaPD8LMy51YiazgWuno2Qglo3x5qF7X00IWTF688MwQy1Epbw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

使用二分查找的基础条件是数组是有序数组。

题目还可能强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下表可能不是唯一的。

要在二分查找的过程中，保持不变量，这也就是「循环不变量」

- 二分法第一种写法：定义 target 是在一个在左闭右闭的区间里，「也就是[left, right] （这个很重要）」。

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里，[left, right] 
        while (left <= right) { // 当left==right，区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle;
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right]，return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
        return right + 1;
    }
};
```

``` Go
func main(){
	arr1 := []int{4}
	arr2 := []int{1, 3}
	arr3 := []int{1, 2, 4}
	arr4 := []int{1, 2}
	target := 3

	fmt.Println(binarySearch(arr1, target))
	fmt.Println(binarySearch(arr2, target))
	fmt.Println(binarySearch(arr3, target))
	fmt.Println(binarySearch(arr4, target))

}

func binarySearch(arr []int, target int) int{
	n := len(arr)
	if len(arr) == 0 {
		return 0
	}

	l := 0
	r := n - 1

	for ;l <= r; {
		m := (l + r) / 2 // 如果l+r是奇数，m落在floor(mid)上

		if arr[m] < target {
			l = m + 1
		} else if arr[m] > target {
			r = m - 1
		} else {
			return m
		}
	}

	return r + 1
}
```

时间复杂度：O(logn)

空间复杂度：O(1)

如果target 是在一个在左闭右开的区间里，也就是[left, right) 。

那么循环条件要改成while(left < right>)，因为left == right的时候，在[left, right)是无效的空间

###### 滑动窗口

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：
输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

暴力解法：两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2) 。

循环嵌套。for设置子序列起点为i。for设置子序列终止位置为j。一旦发现子序列和超过了s，更新result。一旦符合条件就break。

滑动窗口：「就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果」。

![image](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6MwIsdYLFnPSXSJ3WgSPQRf3oaBEAYc57vWs1aSc4YMjmMSawj3QQxd4A81P4XYF6sibPK0lZ1ic4w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

解题的关键在于 窗口的起始位置如何移动

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6MwIsdYLFnPSXSJ3WgSPQRwVdiauYqiaHicaIsJkhCZicyrv7SajaghdlDYdIjnBWhX35Q1SSBom5aAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

```Go

```

「**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**」

时间复杂度：O(n)
空间复杂度：O(1)

###### 链表

什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点是由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链表的类型

- 单链表

链接的入口点称为列表的头结点也就是head。

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNMeIicPicIopP33KcAsaCPoorsKIsicR6xfQUE8KicGEzYKWaohZxuRqD8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 双向链表

单链表中的节点只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNPCIL5G56YOXZGXZKASpKpBstuzUDcKk2icADEUkF3EljRePGKTp71Ow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNwZRkJw0Rw8zuXibQ4QoVTWEqrPwwA5sK7kGtCsic70qiavMD2rHWBRPTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 链表的存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

不定义构造函数是可以的，C++默认生成一个构造函数。但是这个构造函数不会初始化任何成员变化

如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

```C++
ListNode* head = new ListNode();
head->val = 5;
```

- 链表的操作

- 删除节点

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNB6R7wzBmiahbdDC3ic8zLpyD0K7IPtic1KRB0JlSBnhAvyibDfl9kXJvibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

只要将C节点的next指针 指向E节点就可以了。

C++里最好是再手动释放这个D节点，释放这块内存。其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。

- 添加节点

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNxjia1uOhyXKAXxdtM2Rx6vJOB17O8oFa9Fd815ibHY06cNljjhzic5HyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

链表的增添和删除都是O(1)操作，也不会影响到其他节点。

但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。

所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。

所以在写代码的时候，需要单独写一段逻辑来处理移除头结点的情况。

其实「可以设置一个虚拟头结点」，这样原链表的所有节点就都可以按照统一的方式进行移除了。不过，return 头结点的时候，return dummyNode->next;， 这才是新的头结点

- 比较数组和链表

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dN2ou5t2CBEB460SicMyaHBia4ia7wcDC4INicXmiboQAcp6QpLgu4YHXMwtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。


- 大文件排序
- 基本排序，哪些是稳定的
- 编码中一般会用到哪些数据结构
- 链表和数组相比, 有什么优缺点
- 如何判断两个无环单链表有没有交叉点
- 如何判断一个单链表有没有环, 并找出入环点
- 手写一个快速排序
- 一个非常大的数组，让其中两个数想加等于1000怎么算
- 10万个数，从小到大输出（分治法、内存排序、多路归并）
- 10万单词，找出重复最高的几个（map，频次，堆排序）
- 给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的（redis的zset）
- 10亿个数，找出最大的10个（大小为10的小根堆，分治法与多路归并）
- todo

