# 服务端重点-算法

## 端到端

#### 算法与数据结构

[leetcode刷题指南](https://leetcode-cn.com/circle/article/wGp7Y9/)

##### 算法分析

###### 算法复杂度

省略常数时：
O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)

平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？

其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，「但我们统一说 logn，也就是忽略底数的描述」。

###### 二分法 [link](https://mp.weixin.qq.com/s/fCf5QbPDtE6SSlZ1yh_q8Q)

问题：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

分析：插入目标值，无非四种情况
![image](https://mmbiz.qpic.cn/mmbiz_png/F1VzfUpxxe7XJru4qDFXKM7asqfwvgEGFqBfLgibiaPD8LMy51YiazgWuno2Qglo3x5qF7X00IWTF688MwQy1Epbw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

使用二分查找的基础条件是数组是有序数组。

题目还可能强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下表可能不是唯一的。

要在二分查找的过程中，保持不变量，这也就是「循环不变量」

- 二分法第一种写法：定义 target 是在一个在左闭右闭的区间里，「也就是[left, right] （这个很重要）」。

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里，[left, right] 
        while (left <= right) { // 当left==right，区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle;
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right]，return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
        return right + 1;
    }
};
```

```Go
func main(){
	arr1 := []int{4}
	arr2 := []int{1, 3}
	arr3 := []int{1, 2, 4}
	arr4 := []int{1, 2}
	target := 3

	fmt.Println(binarySearch(arr1, target))
	fmt.Println(binarySearch(arr2, target))
	fmt.Println(binarySearch(arr3, target))
	fmt.Println(binarySearch(arr4, target))

}

func binarySearch(arr []int, target int) int{
	n := len(arr)
	if len(arr) == 0 {
		return 0
	}

	l := 0
	r := n - 1

	for ;l <= r; {
		m := (l + r) / 2 // 如果l+r是奇数，m落在floor(mid)上

		if arr[m] < target {
			l = m + 1
		} else if arr[m] > target {
			r = m - 1
		} else {
			return m
		}
	}

	return r + 1
}
```

时间复杂度：O(logn)

空间复杂度：O(1)

如果target 是在一个在左闭右开的区间里，也就是[left, right) 。

那么循环条件要改成while(left < right>)，因为left == right的时候，在[left, right)是无效的空间

###### 滑动窗口

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：
输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

暴力解法：两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2) 。

循环嵌套。for设置子序列起点为i。for设置子序列终止位置为j。一旦发现子序列和超过了s，更新result。一旦符合条件就break。

滑动窗口：「就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果」。

![image](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6MwIsdYLFnPSXSJ3WgSPQRf3oaBEAYc57vWs1aSc4YMjmMSawj3QQxd4A81P4XYF6sibPK0lZ1ic4w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

解题的关键在于 窗口的起始位置如何移动

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6MwIsdYLFnPSXSJ3WgSPQRwVdiauYqiaHicaIsJkhCZicyrv7SajaghdlDYdIjnBWhX35Q1SSBom5aAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

```Go

```

「**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**」

时间复杂度：O(n)
空间复杂度：O(1)

###### 链表

什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点是由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

- 数组与链表的区别 [link](https://blog.csdn.net/qq_25806863/article/details/70607204)

拿几个人一起去看电影时坐座位为例。
- 数组的特点
  - 在内存中，数组是一块连续的区域。 拿上面的看电影来说，这几个人在电影院必须坐在一起。
  - 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 比如看电影时，为了保证10个人能坐在一起，必须提前订好10个连续的位置。这样的好处就是能保证10个人可以在一起。但是这样的缺点是，如果来的人不够10个，那么剩下的位置就浪费了。如果临时有多来了个人，那么10个就不够用了，这时可能需要将第11个位置上的人挪走，或者是他们11个人重新去找一个11连坐的位置，效率都很低。如果没有找到符合要求的作为，那么就没法坐了。
  - 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 比如原来去了5个人，然后后来又去了一个人要坐在第三个位置上，那么第三个到第五个都要往后移动一个位子，将第三个位置留给新来的人。 当这个人走了的时候，因为他们要连在一起的，所以他后面几个人要往前移动一个位置，把这个空位补上。
  - 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
  - 不利于扩展，数组定义的空间不够时要重新定义数组。
- 链表的特点
  - 在内存中可以存在任何地方，不要求连续。 在电影院几个人可以随便坐。
  - 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。 第一个人知道第二个人的座位号，第二个人知道第三个人的座位号……
  - 增加数据和删除数据很容易。 再来个人可以随便坐，比如来了个人要做到第三个位置，那他只需要把自己的位置告诉第二个人，然后问第二个人拿到原来第三个人的位置就行了。其他人都不用动。
  - 查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。 要找到第三个人，必须从第一个人开始问起。
  - 不指定大小，扩展方便。链表大小不用定义，数据随意增删。

数组的优点
- 随机访问性强
- 查找速度快
数组的缺点
- 插入和删除效率低
- 可能浪费内存
- 内存空间要求高，必须有足够的连续内存空间。
- 数组大小固定，不能动态拓展
链表的优点
- 插入删除速度快
- 内存利用率高，不会浪费内存
- 大小没有固定，拓展很灵活。
链表的缺点
- 不能随机查找，必须从第一个开始遍历，查找效率低


链表的类型

- 单链表

链接的入口点称为列表的头结点也就是head。

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNMeIicPicIopP33KcAsaCPoorsKIsicR6xfQUE8KicGEzYKWaohZxuRqD8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 双向链表

单链表中的节点只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNPCIL5G56YOXZGXZKASpKpBstuzUDcKk2icADEUkF3EljRePGKTp71Ow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNwZRkJw0Rw8zuXibQ4QoVTWEqrPwwA5sK7kGtCsic70qiavMD2rHWBRPTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 链表的存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

不定义构造函数是可以的，C++默认生成一个构造函数。但是这个构造函数不会初始化任何成员变化

如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

```C++
ListNode* head = new ListNode();
head->val = 5;
```

- 链表的操作
- 删除节点

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNB6R7wzBmiahbdDC3ic8zLpyD0K7IPtic1KRB0JlSBnhAvyibDfl9kXJvibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

只要将C节点的next指针 指向E节点就可以了。

C++里最好是再手动释放这个D节点，释放这块内存。其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。

- 添加节点

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dNxjia1uOhyXKAXxdtM2Rx6vJOB17O8oFa9Fd815ibHY06cNljjhzic5HyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

链表的增添和删除都是O(1)操作，也不会影响到其他节点。

但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。

所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。

所以在写代码的时候，需要单独写一段逻辑来处理移除头结点的情况。

其实「可以设置一个虚拟头结点」，这样原链表的所有节点就都可以按照统一的方式进行移除了。不过，return 头结点的时候，return dummyNode->next;， 这才是新的头结点

- 比较数组和链表

![image](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CMXzaTI35yibuOwzUQA9dN2ou5t2CBEB460SicMyaHBia4ia7wcDC4INicXmiboQAcp6QpLgu4YHXMwtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

- 大文件排序
- 基本排序，哪些是稳定的
- 编码中一般会用到哪些数据结构
- 链表和数组相比, 有什么优缺点
- 如何判断两个无环单链表有没有交叉点
- 如何判断一个单链表有没有环, 并找出入环点
- 手写一个快速排序
- 一个非常大的数组，让其中两个数想加等于1000怎么算
- 10万个数，从小到大输出（分治法、内存排序、多路归并）
- 10万单词，找出重复最高的几个（map，频次，堆排序）
- 给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的（redis的zset）
- 10亿个数，找出最大的10个（大小为10的小根堆，分治法与多路归并）
- todo
